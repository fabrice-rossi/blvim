#' Create a complete variability plot for spatial interaction models in a data
#' frame
#'
#' This function combines spatial variability interaction model representations
#' similar to the ones produced by [autoplot.sim_list()] into a single ggplot.
#' It provides an alternative graphical representation to the one produced by
#' [autoplot.sim_df()] and by [grid_autoplot()] for collection of spatial
#' interaction models in a `sim_df` object.
#'
#' The rationale of [autoplot.sim_df()] is to display a single value for each
#' spatial interaction model (SIM) in the `sim_df` data frame. On the contrary,
#' this function produces a graphical representation of the variability of a
#' partition of the SIMs in the data frame, using [autoplot.sim_list()] as the
#' graphical engine.
#'
#' The `key` parameter is used to partition the collection of SIMs. It can be
#' any expression which can be evaluated in the context of the `sim_df`
#' parameter. The function uses this parameter as the wrapping variable in a
#' call to [ggplot2::facet_wrap()]. It also uses it as a way to specific a
#' partition of the SIMs: each panel of the final figure is essentially the
#' variability graph generated by [autoplot.sim_list()] for the subset of the
#' SIMs in `sim_df` that match the corresponding value of `key`.
#'
#' Parameters of [ggplot2::facet_wrap()] can be set using the `fw_params`
#' parameter (in a list).
#'
#' @param sim_df a data frame of spatial interaction models, an object of class
#'   `sim_df`
#' @param key the wrapping variable which acts as group identifier for spatial
#'   interaction models
#' @inheritParams autoplot.sim_list
#' @param fw_params parameters for the [ggplot2::facet_wrap] call (if non
#'   `NULL`)
#' @param ... additional parameters passed to [autoplot.sim_list()]
#'
#' @returns a ggplot object
#' @export
#'
#' @examplesIf requireNamespace("ggplot2", quietly = TRUE)
#' positions <- matrix(rnorm(10 * 2), ncol = 2)
#' distances <- as.matrix(dist(positions))
#' production <- rep(1, 10)
#' attractiveness <- c(2, rep(1, 9))
#' all_flows <- grid_blvim(distances, production, seq(1.05, 1.45, by = 0.1),
#'   seq(1, 3, by = 0.5),
#'   attractiveness,
#'   bipartite = FALSE,
#'   epsilon = 0.1, iter_max = 1000,
#'   destination_data = list(names = LETTERS[1:10], positions = positions),
#'   origin_data = list(names = LETTERS[1:10], positions = positions)
#' )
#' all_flows_df <- sim_df(all_flows)
#' ## group models by iteration number
#' grid_var_autoplot(all_flows_df, iterations)
#' ## or by convergence status (showing destination)
#' grid_var_autoplot(all_flows_df, converged, flow = "destination")
#' ## using positions
#' grid_var_autoplot(all_flows_df, iterations,
#'   flow = "destination",
#'   with_positions = TRUE
#' )
grid_var_autoplot <- function(sim_df,
                              key,
                              flows = c("full", "destination", "attractiveness"),
                              with_names = FALSE,
                              with_positions = FALSE,
                              cut_off = 100 * .Machine$double.eps^0.5,
                              adjust_limits = FALSE,
                              qmin = 0.05,
                              qmax = 0.95,
                              normalisation = c("origin", "full", "none"),
                              fw_params = NULL,
                              ...) {
  rlang::check_installed("ggplot2", reason = "to use `grid_var_autoplot()`")
  if (!inherits(sim_df, "sim_df")) {
    cli::cli_abort("{.arg sim_df} must be a {.cls sim_df} object")
  }
  rlang::check_required(key)
  flows <- rlang::arg_match(flows)
  normalisation <- rlang::arg_match(normalisation)
  if (with_positions) {
    if (flows == "destination" || flows == "attractiveness") {
      if (is.null(destination_positions(sim_column(sim_df)))) {
        cli::cli_abort("Missing destination location positions")
      }
    }
    if (flows == "full") {
      cli::cli_warn(c("{.arg flows} = {.str full} cannot be combined with {.arg with_positions} = {.val TRUE}",
        "!" = "proceeding with {.arg with_positions} set to {.val FALSE}"
      ))
    }
  }
  expr <- rlang::enquo(key)
  val <- rlang::eval_tidy({{ expr }}, sim_df)
  val_name <- rlang::as_label(expr)
  pre_data <- tapply(
    sim_column(sim_df),
    val,
    function(a_sim) {
      sim_data <- fortify.sim_list(a_sim,
        data = NULL, flows = flows,
        with_names = with_names, normalisation = normalisation
      )
      sim_data_stat <- stat_sim_list(sim_data, flows, quantiles = c(qmin, qmax))
      sim_data_stat
    }
  )
  if (is.factor(val)) {
    final_data <- combine_df(pre_data, factor(levels(val), levels(val)), val_name)
  } else {
    final_data <- combine_df(pre_data, sort(unique(val)), val_name)
  }
  pre <- sim_list_autoplot(
    sim_column(sim_df),
    final_data,
    flows,
    with_names,
    with_positions,
    cut_off,
    adjust_limits,
    normalisation,
    ...
  )
  fw_parameters <- list(facets = ggplot2::vars(.data[[val_name]]))
  if (!is.null(fw_params)) {
    fw_parameters <- c(fw_parameters, fw_params)
  }
  pre +
    do.call(ggplot2::facet_wrap, fw_parameters)
}
